/**
 * OpenSearch Bulk Upload Script
 * 
 * Uploads restaurant data (RestaurantID + Cuisine) to OpenSearch.
 * Run this AFTER the yelp-scraper.js has completed.
 * 
 * PREREQUISITES:
 *   1. Install dependencies: npm install
 *   2. Run yelp-scraper.js first (creates restaurants-opensearch.json)
 *   3. Set environment variables below or in your shell:
 *      - OPENSEARCH_ENDPOINT  (e.g., https://search-restaurants-xxxxx.us-east-1.es.amazonaws.com)
 *      - OPENSEARCH_USERNAME  (master user)
 *      - OPENSEARCH_PASSWORD  (master password)
 * 
 * USAGE:
 *   node opensearch-bulk-upload.js
 */

const https = require("https");
const fs = require("fs");

// ============================================================
// CONFIGURATION - CHANGE THESE
// ============================================================
const OPENSEARCH_ENDPOINT = process.env.OPENSEARCH_ENDPOINT || "https://YOUR_OPENSEARCH_ENDPOINT_HERE";
const OPENSEARCH_USERNAME = process.env.OPENSEARCH_USERNAME || "master";
const OPENSEARCH_PASSWORD = process.env.OPENSEARCH_PASSWORD || "YOUR_PASSWORD_HERE";

const INDEX_NAME = "restaurants";
const DATA_FILE = "restaurants-opensearch.json"; // Generated by yelp-scraper.js

// ============================================================
// MAIN
// ============================================================
async function main() {
  console.log("=== OpenSearch Bulk Upload ===\n");

  // Validate config
  if (OPENSEARCH_ENDPOINT.includes("YOUR_OPENSEARCH_ENDPOINT_HERE")) {
    console.error("ERROR: Please set OPENSEARCH_ENDPOINT!");
    console.error("  Run with: OPENSEARCH_ENDPOINT=https://your-domain.us-east-1.es.amazonaws.com node opensearch-bulk-upload.js");
    process.exit(1);
  }

  // Read the data file
  if (!fs.existsSync(DATA_FILE)) {
    console.error(`ERROR: ${DATA_FILE} not found. Run yelp-scraper.js first.`);
    process.exit(1);
  }

  const restaurants = JSON.parse(fs.readFileSync(DATA_FILE, "utf-8"));
  console.log(`Loaded ${restaurants.length} restaurants from ${DATA_FILE}\n`);

  // Step 1: Create the index (if it doesn't exist)
  console.log("Step 1: Creating index...");
  try {
    await createIndex();
    console.log(`  Index "${INDEX_NAME}" created (or already exists)\n`);
  } catch (err) {
    if (err.message.includes("resource_already_exists_exception") || err.message.includes("400")) {
      console.log(`  Index "${INDEX_NAME}" already exists, continuing...\n`);
    } else {
      console.error("  Error creating index:", err.message);
      // Continue anyway - the index might already exist
    }
  }

  // Step 2: Bulk upload in batches
  console.log("Step 2: Bulk uploading data...");
  const BATCH_SIZE = 100;
  let totalUploaded = 0;

  for (let i = 0; i < restaurants.length; i += BATCH_SIZE) {
    const batch = restaurants.slice(i, i + BATCH_SIZE);
    const bulkBody = buildBulkBody(batch);

    try {
      const response = await makeRequest("POST", `/${INDEX_NAME}/_bulk`, bulkBody, "application/x-ndjson");
      const result = JSON.parse(response);

      if (result.errors) {
        const errorItems = result.items.filter((item) => item.index?.error);
        console.log(`  Batch ${Math.floor(i / BATCH_SIZE) + 1}: ${batch.length - errorItems.length} succeeded, ${errorItems.length} failed`);
        if (errorItems.length > 0) {
          console.log(`    Sample error: ${JSON.stringify(errorItems[0].index.error)}`);
        }
      } else {
        console.log(`  Batch ${Math.floor(i / BATCH_SIZE) + 1}: ${batch.length} uploaded successfully`);
      }
      totalUploaded += batch.length;
    } catch (error) {
      console.error(`  Batch ${Math.floor(i / BATCH_SIZE) + 1} failed:`, error.message);
    }

    // Small delay between batches
    await sleep(100);
  }

  console.log(`\n=== Upload complete: ${totalUploaded} documents processed ===`);

  // Step 3: Verify
  console.log("\nStep 3: Verifying...");
  try {
    const countResponse = await makeRequest("GET", `/${INDEX_NAME}/_count`);
    const countResult = JSON.parse(countResponse);
    console.log(`  Total documents in "${INDEX_NAME}" index: ${countResult.count}`);
  } catch (err) {
    console.log("  Could not verify count:", err.message);
  }

  // Test search
  try {
    const searchBody = JSON.stringify({
      size: 3,
      query: { match: { Cuisine: "japanese" } },
    });
    const searchResponse = await makeRequest("POST", `/${INDEX_NAME}/_search`, searchBody);
    const searchResult = JSON.parse(searchResponse);
    console.log(`  Sample search for "japanese": found ${searchResult.hits?.total?.value || 0} results`);
    if (searchResult.hits?.hits?.length > 0) {
      searchResult.hits.hits.forEach((hit, i) => {
        console.log(`    ${i + 1}. ${hit._source.RestaurantID} (${hit._source.Cuisine})`);
      });
    }
  } catch (err) {
    console.log("  Could not run test search:", err.message);
  }

  console.log("\nDone! OpenSearch is ready.");
}

// ============================================================
// OPENSEARCH OPERATIONS
// ============================================================
async function createIndex() {
  const indexSettings = JSON.stringify({
    settings: {
      number_of_shards: 1,
      number_of_replicas: 0, // Single node, no replicas needed
    },
    mappings: {
      properties: {
        RestaurantID: { type: "keyword" },
        Cuisine: { type: "keyword" },
      },
    },
  });

  return makeRequest("PUT", `/${INDEX_NAME}`, indexSettings);
}

function buildBulkBody(restaurants) {
  let body = "";
  for (const r of restaurants) {
    // Action line
    body += JSON.stringify({ index: { _index: INDEX_NAME, _id: r.RestaurantID } }) + "\n";
    // Document line
    body += JSON.stringify({ RestaurantID: r.RestaurantID, Cuisine: r.Cuisine }) + "\n";
  }
  return body;
}

// ============================================================
// HTTP REQUEST HELPER
// ============================================================
function makeRequest(method, path, body, contentType) {
  return new Promise((resolve, reject) => {
    const url = new URL(OPENSEARCH_ENDPOINT);
    const auth = Buffer.from(`${OPENSEARCH_USERNAME}:${OPENSEARCH_PASSWORD}`).toString("base64");

    const options = {
      hostname: url.hostname,
      port: url.port || 443,
      path: path,
      method: method,
      headers: {
        "Content-Type": contentType || "application/json",
        Authorization: `Basic ${auth}`,
      },
    };

    const protocol = url.protocol === "http:" ? require("http") : https;
    const req = protocol.request(options, (res) => {
      let data = "";
      res.on("data", (chunk) => (data += chunk));
      res.on("end", () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data);
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data.substring(0, 500)}`));
        }
      });
    });

    req.on("error", reject);
    if (body) {
      req.write(body);
    }
    req.end();
  });
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Run
main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
